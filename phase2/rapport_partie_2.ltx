\documentclass{article}
\usepackage{graphicx}
\usepackage{svg}
\usepackage[a4paper, margin=1in]{geometry}
\renewcommand{\familydefault}{\sfdefault}
\setlength{\parindent}{0pt}
\usepackage[table]{xcolor}
\usepackage{booktabs}
\usepackage{epigraph}
\usepackage{lmodern}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\lstset{
  basicstyle=\ttfamily,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{orange},
  showstringspaces=false,
  breaklines=true,
  frame=single
}

\title{INFOH303 - Projet de Système d’Inventaire pour un
RPG - Partie 2}
\author{Bilal Vandenberge}
\date{Mars 2025}

\begin{document}

\begin{center}
    {\LARGE\textbf{INFOH303 - Projet de Système d’Inventaire pour un RPG - Partie 2 - Rapport}}\\[0.5em]
    \rule{0.9\textwidth}{1pt}
\end{center}

\vspace{5pt}
\begin{center}
% \rowcolors{3}{green!25}{yellow!50}
\begin{tabular}{ *3l }    \toprule
\textbf{Prénom} & \textbf{Nom} & \textbf{Matricule} \\\bottomrule
Bilal & Vandenberge & 000593438  \\\bottomrule
Lucas & Verbeiren & 000591223  \\\bottomrule
Ethan & Van Ruyskensvelde & 000589640  \\\bottomrule
Rares & Radu-Loghin & 000590079  \\\bottomrule
 %\hline
\end{tabular}
\end{center}
\vspace{5pt}

%-------------------------------------------------------------------

\section{Méthode d’extraction des données}

Pour remplir la base de données, nous avons développé un script \texttt{insert.py} (situé dans \texttt{src/database/insert.py}). Ce script commence par créer les tables si elles ne sont pas encore présentes dans la base de données (en appelant la fonction \texttt{create\_database\_and\_tables()} située dans le fichier \texttt{src/database/create.py}).

Ensuite, pour chaque fichier présent dans le dossier \texttt{data}, nous lisons et extrayons les données, puis tentons de les insérer dans la base de données. Avant chaque insertion, nous effectuons une vérification afin de nous assurer que les données soient valides, comme le type (par exemple \texttt{int}, \texttt{string}, etc.) et le contenu, en vérifiant notamment si une donnée similaire a déjà été insérée. 

Si une donnée est incorrecte (par exemple, si une information est manquante ou si une chaîne de caractères est présente là où un entier est attendu), elle n'est pas ajoutée à la base de données. Ce processus est répété pour chaque donnée contenue dans les fichiers.

Par souci de clarté et de modularité, le traitement de chaque fichier est organisé en fonctions distinctes.


\section{Requêtes demandées}
Pour exécuter et afficher les différentes requêtes demandées, il suffit de lancer le script suivant :

\begin{center}
\texttt{python3 src/database/additional\_request.py}
\end{center}


\subsection{Les 10 joueurs ayant le plus d’or}
\subsubsection{SQL}
\begin{verbatim}
SELECT p.Name, p.Money 
FROM Players p 
ORDER BY p.Money DESC LIMIT 10;
\end{verbatim}

\subsubsection{Algèbre relationnelle}
\begin{align*}
  & \delta_{10} \left( \tau_{\text{Money desc}} \left( \pi_{\text{Name, Money}}(\text{Players}) \right) \right)
\end{align*}

\subsubsection{Calcul tuple}

\subsection{Le joueur ayant le plus de personnages de la même classe}
\subsubsection{SQL}
\begin{verbatim}
SELECT p.Name, c.Class, COUNT(*) AS nbCharacters
FROM Players p
JOIN Characters c ON p.Name = c.Username
GROUP BY p.Name, c.Class
ORDER BY nbCharacters DESC LIMIT 1;
\end{verbatim}

\subsubsection{Algèbre relationnelle}

\subsubsection{Calcul tuple}

\subsection{La quête ayant la plus grosse récompense en or par niveau de difficulté}
\subsubsection{SQL}
\begin{verbatim}
WITH QuestGold AS (
SELECT q.Name AS QuestName, q.Difficulty, SUM(i.Price * r.Quantity) AS TotalGold
FROM Quests q
JOIN Rewards r ON q.Name = r.QuestName
JOIN Items i ON r.ItemName = i.Name
GROUP BY q.Name, q.Difficulty
),
RankedQuests AS (
    SELECT *, ROW_NUMBER() OVER (PARTITION BY Difficulty ORDER BY TotalGold DESC) AS `rank`
    FROM QuestGold
)
SELECT QuestName, Difficulty, TotalGold
FROM RankedQuests
WHERE `rank` = 1;
\end{verbatim}

\subsubsection{Algèbre relationnelle}

\subsubsection{Calcul tuple}

\subsection{Le PNJ possédant l'inventaire contenant les objets dont la valeur en or cumulée est la plus
importante}
\subsubsection{SQL}
\begin{verbatim}
SELECT npc.Name, SUM(i.Price * npcII.Quantity) AS TotalValue
FROM NPCs npc
JOIN NPCItemInventories npcII ON npc.Name = npcII.NPCName
JOIN Items i ON npcII.ItemName = i.Name
GROUP BY npc.Name
ORDER BY TotalValue DESC LIMIT 1;
\end{verbatim}

\subsubsection{Algèbre relationnelle}

\subsubsection{Calcul tuple}

\subsection{Le type d'objet (arme, armure, potion ou relique) le plus souvent offert en récompense de quêtes de niveau 5}
\subsubsection{SQL}
\begin{verbatim}
SELECT item.Type, COUNT(*) as apparitions
FROM Items item
WHERE item.Name in (
    SELECT reward.ItemName
    FROM Rewards reward
    WHERE reward.ItemName <> 'Or' AND
        reward.QuestName in (
        SELECT quest.Name
        FROM Quests quest
        WHERE quest.Difficulty = 5
    )
)
GROUP BY item.Type
ORDER BY apparitions desc LIMIT 1;
\end{verbatim}

\subsubsection{Algèbre relationnelle}

\subsubsection{Calcul tuple}

\subsection{Les monstres avec les meilleures récompenses en valeur en or cumulée en fonction de leurs points
de vie}
\subsubsection{SQL}
\begin{verbatim}
SELECT (MonsterCost/MonsterHealth) AS Ratio, Name
FROM (
    SELECT SUM(ItemPrice * lootQuantity) as MonsterCost, MonsterName
    FROM
    (
        SELECT 
            items.Name as ItemName,
            items.Price as ItemPrice,
            loot.MonsterName as MonsterName,
            loot.Quantity as lootQuantity
        FROM Items items
        JOIN MonsterLoots loot ON items.Name = loot.LootName
    ) as subrequest
    GROUP BY MonsterName
) as monsterHealthAndPrice
JOIN Monsters monsters on monsters.Name = MonsterName
ORDER BY Ratio desc LIMIT 1;
\end{verbatim}

\subsubsection{Algèbre relationnelle}

\subsubsection{Calcul tuple}


\section{Justifications}



\end{document}
